# Copyright 2017 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//packages/package.gni")
import("BUILD.generated.gni")
import("BUILD.generated_tests.gni")

################################################################################
# Public targets

group("boringssl") {
  public_deps = [
    ":libcrypto",
    ":libssl",
  ]
}


################
# libcrypto.so #
################
if (is_fuchsia) {
  package("libcrypto") {
    system_image = true
    deps = [
      ":crypto",
    ]
    libraries = [ {
          name = "libcrypto.so"
        } ]
  }
}

shared_library("crypto") {
  visibility = [ ":*" ]
  public_configs = [ ":boringssl_config" ]
  sources = crypto_sources
  if (current_cpu == "arm64") {
    if (is_mac) {
      sources += crypto_sources_ios_aarch64
    } else if (is_fuchsia || is_linux) {
      sources += crypto_sources_linux_aarch64
    } else {
      assert(false, "unsupported OS: {{current_os}}")
    }
  } else if (current_cpu == "x64") {
    if (is_mac) {
      sources += crypto_sources_mac_x86_64
    } else if (is_fuchsia || is_linux) {
      sources += crypto_sources_linux_x86_64
    } else {
      assert(false, "unsupported OS: {{current_os}}")
    }
  }
  configs += [ ":internal_config" ]
}


#############
# libssl.so #
#############
if (is_fuchsia) {
  package("libssl") {
    system_image = true
    deps = [
      ":ssl",
    ]
    libraries = [ {
          name = "libssl.so"
        } ]
    resources = [ {
          path = rebase_path("certdata.pem")
          dest = "boringssl/cert.pem"
        } ]
  }
}

shared_library("ssl") {
  visibility = [ ":*" ]
  public_configs = [ ":boringssl_config" ]
  sources = ssl_sources
  configs += [ ":internal_config" ]
  deps = [ ":crypto" ]
}


##########################
# bssl command line tool #
##########################
if (is_fuchsia) {
  package("boringssl_tool") {
    system_image = true
    deps = [
      ":bssl",
    ]
    binaries = [ {
          name = "bssl"
        } ]
  }
} else {
  group("boringssl_tool") {
    deps = [
      ":bssl_tool",
    ]
  }
}


# See //third_party/boringssl/tool/CMakeLists.txt
executable("bssl") {
  visibility = [ ":*" ]
  sources = [
    "src/tool/args.cc",
    "src/tool/ciphers.cc",
    "src/tool/client.cc",
    "src/tool/const.cc",
    "src/tool/digest.cc",
    "src/tool/file.cc",
    "src/tool/generate_ed25519.cc",
    "src/tool/genrsa.cc",
    "src/tool/pkcs12.cc",
    "src/tool/rand.cc",
    "src/tool/server.cc",
    "src/tool/sign.cc",
    "src/tool/speed.cc",
    "src/tool/tool.cc",
    "src/tool/transport_common.cc",
  ]
  configs += [ "//third_party/boringssl:internal_config" ]
  deps = [
    ":crypto",
    ":ssl",
  ]
}


##############
# Unit tests #
##############
if (is_fuchsia) {
  package("boringssl_tests") {
    testonly = true
    system_image = true
    deps = [
      ":crypto_test",
      ":ssl_test",
    ]
    tests = [
      {
        name = "crypto_test"

        # This test takes a long time to run, and it is included in every subset
        # of the Fuchsia build.
        # TODO(bgoldman): Find a way to skip this test when runtests is set to
        # skip "large" tests.
        disabled = true
      },
      {
        name = "ssl_test"
      },
    ]
  }
} else {
  group("tests") {
    deps = [
      ":crypto_test",
      ":ssl_test",
    ]
  }
}

executable("crypto_test") {
  testonly = true
  visibility = [ ":*" ]
  sources = crypto_test_sources + test_support_sources
  configs += [ ":test_config" ]
  deps = [
    ":crypto",
    "//third_party/gtest",
  ]
}

executable("ssl_test") {
  testonly = true
  visibility = [ ":*" ]
  sources = ssl_test_sources + test_support_sources
  configs += [ ":test_config" ]
  deps = [
    ":ssl",
    "//third_party/gtest",
  ]
}

################################################################################
# Configs
config("boringssl_config") {
  include_dirs = [ "src/include" ]
  if (is_fuchsia) {
    # rand_fuchsia uses a system call
    libs = [ "zircon" ]
  }
}

config("internal_config") {
  visibility = [ ":*" ]
  defines = [
    "BORINGSSL_ALLOW_CXX_RUNTIME",
    "BORINGSSL_IMPLEMENTATION",
    "BORINGSSL_NO_STATIC_INITIALIZER",
    "BORINGSSL_SHARED_LIBRARY",
    "OPENSSL_SMALL",
  ]
  if (is_linux || is_mac) {
    # pthread_rwlock_t on host requires a feature flag.
    defines += [ "_XOPEN_SOURCE=700" ]
  }

  # TODO(aarongreen): Before we can enable the optimized assembly on ARM, we
  # need to have GN arguments or similar to indicate whether we have crypto
  # support.  When we don't, we should fall back to using OPENSSL_NO_ASM.  We
  # should be able to run on platforms without crypto support even when building
  # with it, since BoringSSL does the runtime check of 'OPENSSL_cpuid_setup',
  # but to do this we'll need to provide an equivalent implementation, e.g.
  # "crypto/cpu-aarch64-fuchsia.c".
  if (current_cpu == "arm64") {
    if (is_fuchsia) {
      defines += [ "OPENSSL_NO_ASM" ]
    } else if (!is_linux && !is_mac) {
      assert(false, "unsupported OS: {{current_os}}")
    }
  } else if (current_cpu == "x64") {
    if (!is_fuchsia && !is_linux && !is_mac) {
      assert(false, "unsupported OS: {{current_os}}")
    }
  } else {
    assert(false, "unsupported architecture: {{current_cpu}}")
  }
  cflags = [ "-Wno-unused-function" ]
  configs = [
    ":boringssl_config",
    "//build/config:shared_library_config",
  ]
}

config("test_config") {
  visibility = [ ":*" ]
  include_dirs = [
    "src/crypto/test",
    "src/ssl/test",
    "//third_party/gtest/include",
  ]
  configs = [ ":internal_config" ]
}
